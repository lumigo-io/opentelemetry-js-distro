import fs from 'fs';
import { join } from 'path';
import { GenericContainer, StartedTestContainer, Wait } from 'testcontainers';
import { itTest } from '../../../integration/setup';
import { installPackage, reinstallPackages, uninstallPackage } from '../../../utils/test-setup';
import { versionsToTest } from '../../../utils/versions';
import { TestApp } from '../../../utils/test-apps';
import AWS from 'aws-sdk';
import { Triggers } from '@lumigo/node-core'
import 'jest-extended';
import 'jest-json';
import {getSpansByAttribute} from '../../../utils/spans';

const INSTRUMENTATION_NAME = '@aws-sdk/client-sqs';
const INSTRUMENTATION_SPANS_FILE_PREFIX = INSTRUMENTATION_NAME.replace('/', '-')
const SPANS_DIR = join(__dirname, 'spans');
const SQS_STARTUP_TIMEOUT = 60_000;
const TIMEOUT = 600_000;
const TEST_APP_DIR = join(__dirname, 'app');
const LOCALSTACK_PORT = 4566;
const SAMPLE_INNER_SNS_MESSAGE_BODY = JSON.stringify({
  "Type": "Notification",
  "MessageId": "sns-message-message-id-123",
  "TopicArn": "arn:aws:sns:us-west-2:123456789:inner-sns",
  "Message": "{}",
  "Timestamp": "2023-01-15T10:29:01.127Z",
  "SignatureVersion": "1",
  "SigningCertURL": "https://sns.us-west-2.amazonaws.com/SimpleNotificationService-123456789.pem",
  "UnsubscribeURL": "https://sns.us-west-2.amazonaws.com/?Action=Unsubscribe&amp;SubscriptionArn=arn:aws:sns:us-west-2:123456789:inner-sns:123456789"
})

describe.each(versionsToTest(INSTRUMENTATION_NAME, INSTRUMENTATION_NAME))(`Instrumentation tests for the ${INSTRUMENTATION_NAME} package`, (versionToTest) => {
  let sqsContainer: StartedTestContainer;
  let testApp: TestApp;
  let sqsPort: number;
  let sqsClient: AWS.SQS;
  const region = 'us-east-1';

  beforeAll(async () => {
    fs.mkdirSync(SPANS_DIR, { recursive: true });

    sqsContainer = await new GenericContainer('localstack/localstack:latest')
      .withEnv('SERVICES', 'sqs')
      .withExposedPorts(LOCALSTACK_PORT)
      .withWaitStrategy(Wait.forLogMessage('Ready.'))
      .withStartupTimeout(SQS_STARTUP_TIMEOUT)
      .start();

    sqsPort = sqsContainer.getMappedPort(LOCALSTACK_PORT)
    sqsClient = new AWS.SQS({ endpoint: `http://localhost:${sqsPort}`, region })

    reinstallPackages({ appDir: TEST_APP_DIR })
    installPackage({
      appDir: TEST_APP_DIR,
      packageName: INSTRUMENTATION_NAME,
      packageVersion: versionToTest
    });
  }, TIMEOUT)

  afterAll(async () => {
    if (testApp) {
      await testApp.kill();
    }

    if (sqsContainer) {
      await sqsContainer.stop()
    }

    uninstallPackage({
      appDir: TEST_APP_DIR,
      packageName: INSTRUMENTATION_NAME,
      packageVersion: versionToTest
    });
  }, TIMEOUT)

  itTest(
    {
      testName: `${INSTRUMENTATION_NAME} SQS.receiveMessage: ${versionToTest}`,
      packageName: INSTRUMENTATION_NAME,
      version: versionToTest,
      timeout: TIMEOUT,
    },
    async () => {
      const exporterFile = `${SPANS_DIR}/${INSTRUMENTATION_SPANS_FILE_PREFIX}-receive-message-spans@${versionToTest}.json`;

      const queueUrl = await createTempQueue();
      const { MessageId: expectedMessageId } = await sqsClient.sendMessage({ MessageBody: SAMPLE_INNER_SNS_MESSAGE_BODY, QueueUrl: queueUrl }).promise()

      testApp = new TestApp(TEST_APP_DIR, INSTRUMENTATION_NAME, exporterFile, { LUMIGO_DEBUG: 'true' });

      await testApp.invokeGetPath(`/sqs/receive-message?${testAppQueryParams(queueUrl)}`);

      const spans = await testApp.getFinalSpans();
      const sqsSpans = getSpansByAttribute(spans, "rpc.service", "SQS")
      const sqsReceiveSpan = getSpansByAttribute(sqsSpans, "rpc.method", "ReceiveMessage")[0]

      /*
        This is a guard against having duplicate spans from both aws-sdk instrumentation and the http instrumentation,
        once https://github.com/open-telemetry/opentelemetry-js-contrib/issues/1987 will be fixed
      */
      expect(sqsReceiveSpan).toBeUndefined()

      // Make sure we have http instrumentation spans for the SQS calls generated by the aws-sdk v3 client
      expect(spans).toSatisfyAny(span =>
        span.attributes['http.url'] &&
        queueUrl.startsWith(span.attributes['http.url']) &&
        span.attributes['http.user_agent']?.includes('aws-sdk-nodejs-v3') &&
        span.attributes['http.response.body']?.includes(expectedMessageId) &&
        span.attributes['SKIP_EXPORT'] === undefined
      )
    }
  )

  itTest(
    {
      testName: `${INSTRUMENTATION_NAME} SQS.sendMessage: ${versionToTest}`,
      packageName: INSTRUMENTATION_NAME,
      version: versionToTest,
      timeout: TIMEOUT,
    },
    async () => {
      const exporterFile = `${SPANS_DIR}/${INSTRUMENTATION_SPANS_FILE_PREFIX}-send-message-spans@${versionToTest}.json`;
      testApp = new TestApp(TEST_APP_DIR, INSTRUMENTATION_NAME, exporterFile);

      const queueUrl = await createTempQueue();
      await testApp.invokeGetPath(`/sqs/send-message?${testAppQueryParams(queueUrl)}`);

      const { Messages } = await sqsClient.receiveMessage({ QueueUrl: queueUrl, WaitTimeSeconds: 1 }).promise()
      const expectedMessageId = Messages?.[0].MessageId
      expect(expectedMessageId).toBeDefined()

      const spans = await testApp.getFinalSpans();
      const sqsSpans = getSpansByAttribute(spans, "rpc.service", "SQS")
      const sqsSendSpan = getSpansByAttribute(sqsSpans, "rpc.method", "SendMessage")[0]

      /*
        Remove this and uncomment the other assertions once
        https://github.com/open-telemetry/opentelemetry-js-contrib/issues/1987 is fixed
      */
      expect(sqsSendSpan).toBeUndefined()

      // Make sure we have http instrumentation spans for the SQS calls generated by the aws-sdk v3 client
      expect(spans).toSatisfyAny(span =>
        span.attributes['http.url'] &&
        queueUrl.startsWith(span.attributes['http.url']) &&
        span.attributes['http.user_agent']?.includes('aws-sdk-nodejs-v3') &&
        span.attributes['http.response.body']?.includes(expectedMessageId) &&
        span.attributes['SKIP_EXPORT'] === undefined
      )
    }
  )

  itTest(
    {
      testName: `${INSTRUMENTATION_NAME} SQS.sendMessageBatch: ${versionToTest}`,
      packageName: INSTRUMENTATION_NAME,
      version: versionToTest,
      timeout: TIMEOUT,
    },
    async () => {
      const exporterFile = `${SPANS_DIR}/${INSTRUMENTATION_SPANS_FILE_PREFIX}-send-message-batch-spans@${versionToTest}.json`;
      testApp = new TestApp(TEST_APP_DIR, INSTRUMENTATION_NAME, exporterFile);

      const queueUrl = await createTempQueue();
      await testApp.invokeGetPath(`/sqs/send-message-batch?${testAppQueryParams(queueUrl)}`);

      const { Messages } = await sqsClient.receiveMessage({ QueueUrl: queueUrl, WaitTimeSeconds: 1, MaxNumberOfMessages: 2 }).promise()
      const expectedMessageId = Messages?.[0].MessageId
      expect(expectedMessageId).toBeDefined()

      const spans = await testApp.getFinalSpans();
      const sqsSpans = getSpansByAttribute(spans, "rpc.service", "SQS")
      const sqsSendBatchSpan = getSpansByAttribute(sqsSpans, "rpc.method", "SendMessageBatch")[0]

      /*
        Remove this and uncomment the other assertions once
        https://github.com/open-telemetry/opentelemetry-js-contrib/issues/1987 is fixed
      */
      expect(sqsSendBatchSpan).toBeUndefined()

      // Make sure we have http instrumentation spans for the SQS calls generated by the aws-sdk v3 client
      expect(spans).toSatisfyAny(span =>
        span.attributes['http.url'] &&
        queueUrl.startsWith(span.attributes['http.url']) &&
        span.attributes['http.user_agent']?.includes('aws-sdk-nodejs-v3') &&
        span.attributes['http.response.body']?.includes(expectedMessageId) &&
        span.attributes['SKIP_EXPORT'] === undefined
      )
    }
  )

  const testAppQueryParams = (queueUrl: string) =>  Object.entries({
    region,
    sqsPort,
    queueUrl: encodeURIComponent(queueUrl)
  }).map(keyValue => keyValue.join('=')).join('&')

  const createTempQueue = async () => {
    const queueName = `test-queue-${Math.random().toString(36).substring(7)}`;
    await sqsClient.createQueue({ QueueName: queueName }).promise()
    const queueUrl = `http://localhost:${sqsPort}/000000000000/${queueName}`

    return queueUrl
  }
})